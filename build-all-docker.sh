#!/bin/bash

# Docker Build Script for ASR Services
# Builds all Docker images in the correct dependency order
# Usage: ./build-all-docker.sh [OPTIONS]

set -e  # Exit on any error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
PARALLEL_BUILDS=false
VERBOSE=false
FORCE_REBUILD=false
BUILD_ORCHESTRATOR=true
START_SERVICES=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--parallel)
            PARALLEL_BUILDS=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -f|--force)
            FORCE_REBUILD=true
            shift
            ;;
        --no-orchestrator)
            BUILD_ORCHESTRATOR=false
            shift
            ;;
        --start)
            START_SERVICES=true
            shift
            ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS]"
            echo "Options:"
            echo "  -p, --parallel        Build ASR services in parallel (after base)"
            echo "  -v, --verbose         Show detailed build output"
            echo "  -f, --force           Force rebuild (--no-cache)"
            echo "  --no-orchestrator     Skip building orchestrator service"
            echo "  --start               Start services after successful build"
            echo "  -h, --help           Show this help message"
            exit 0
            ;;
        *)
            echo "Unknown option $1"
            exit 1
            ;;
    esac
done

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to build a Docker image
build_image() {
    local service_name=$1
    local dockerfile_path=$2
    local image_tag=$3
    local build_args=${4:-""}
    
    log_info "Building $service_name..."
    
    local docker_cmd="docker build"
    
    if [ "$FORCE_REBUILD" = true ]; then
        docker_cmd="$docker_cmd --no-cache"
    fi
    
    if [ "$VERBOSE" = false ]; then
        docker_cmd="$docker_cmd -q"
    fi
    
    docker_cmd="$docker_cmd -t $image_tag -f $dockerfile_path $build_args ."
    
    if [ "$VERBOSE" = true ]; then
        log_info "Running: $docker_cmd"
    fi
    
    if eval $docker_cmd; then
        log_success "$service_name built successfully"
        return 0
    else
        log_error "Failed to build $service_name"
        return 1
    fi
}

# Function to check if Docker is running
check_docker() {
    if ! docker info > /dev/null 2>&1; then
        log_error "Docker is not running or not accessible"
        log_info "Please start Docker and try again"
        exit 1
    fi
}

# Function to create .env file interactively
create_env_file() {
    local env_file="backend/.env"
    local temp_env_file="${env_file}.tmp"
    
    log_info "Setting up API keys for ASR services..."
    echo ""
    echo "🔑 API Keys Required for Docker Services"
    echo "========================================"
    echo ""
    echo "You need 2 API keys to run the ASR orchestrator:"
    echo ""
    echo "1. 🤖 GEMINI API KEY"
    echo "   Purpose: AI processing and consensus generation"
    echo "   Get it from: https://makersuite.google.com/app/apikey"
    echo ""
    echo "2. 🔍 TAVILY API KEY"
    echo "   Purpose: Web search validation"
    echo "   Get it from: https://tavily.com/"
    echo ""
    echo "========================================"
    echo ""
    
    # Cleanup function for interrupted setup
    cleanup_env_setup() {
        if [ -f "$temp_env_file" ]; then
            rm -f "$temp_env_file"
            log_warning "Setup interrupted. Temporary files cleaned up."
        fi
    }
    
    # Set trap for cleanup on exit/interrupt
    trap cleanup_env_setup EXIT INT TERM
    
    local gemini_key=""
    local tavily_key=""
    
    # Get Gemini API key
    while true; do
        echo -n "Enter your GEMINI API key: "
        read -r gemini_key
        
        if [ -z "$gemini_key" ]; then
            log_error "Gemini API key cannot be empty"
            echo "Please get your key from: https://makersuite.google.com/app/apikey"
            echo ""
            continue
        fi
        break
    done
    
    # Get Tavily API key
    while true; do
        echo -n "Enter your TAVILY API key: "
        read -r tavily_key
        
        if [ -z "$tavily_key" ]; then
            log_error "Tavily API key cannot be empty"
            echo "Please get your key from: https://tavily.com/"
            echo ""
            continue
        fi
        break
    done
    
    # Create the .env file content (only the 2 keys they need)
    cat > "$temp_env_file" << EOF
# API Keys for ASR Services
# Generated by build-all-docker.sh on $(date)

# Required for AI processing and consensus generation
GEMINI_API_KEY=$gemini_key

# Required for web search validation
TAVILY_API_KEY=$tavily_key
EOF
    
    # Confirm before finalizing
    echo ""
    log_info "Configuration summary:"
    echo "✓ Gemini API key: ${gemini_key:0:20}..."
    echo "✓ Tavily API key: ${tavily_key:0:20}..."
    echo ""
    echo -n "Save configuration to $env_file? (y/n): "
    read -r confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        # Move temp file to final location
        mv "$temp_env_file" "$env_file"
        log_success "Configuration saved to $env_file"
        
        # Set appropriate permissions
        chmod 600 "$env_file"
        log_info "File permissions set to 600 (owner read/write only)"
        
        # Remove trap since we succeeded
        trap - EXIT INT TERM
        return 0
    else
        log_warning "Configuration not saved"
        rm -f "$temp_env_file"
        echo ""
        echo "To build the Docker services, you'll need to:"
        echo "1. Create backend/.env with your API keys"
        echo "2. Run this script again"
        echo ""
        exit 1
    fi
}

# Function to check if required files exist
check_prerequisites() {
    local missing_files=()
    
    # Check Dockerfiles
    local dockerfiles=(
        "backend/src/asr_models/base.Dockerfile"
        "Dockerfile.orchestrator"
        "backend/src/asr_models/whisper/Dockerfile"
        "backend/src/asr_models/wav2vec/Dockerfile"
        "backend/src/asr_models/moonshine/Dockerfile"
        "backend/src/asr_models/mesolitica/Dockerfile"
        "backend/src/asr_models/vosk/Dockerfile"
        "backend/src/asr_models/allosaurus/Dockerfile"
        "backend/src/autocomplete/Dockerfile"
    )
    
    for dockerfile in "${dockerfiles[@]}"; do
        if [ ! -f "$dockerfile" ]; then
            missing_files+=("$dockerfile")
        fi
    done
    
    # Check essential files
    local essential_files=(
        "backend/pyproject.toml"
        "docker-compose.yml"
    )
    
    for file in "${essential_files[@]}"; do
        if [ ! -f "$file" ]; then
            missing_files+=("$file")
        fi
    done
    
    if [ ${#missing_files[@]} -gt 0 ]; then
        log_error "Missing required files:"
        printf '  %s\n' "${missing_files[@]}"
        exit 1
    fi
    
    # Check for .env file
    if [ ! -f "backend/.env" ]; then
        log_warning "No .env file found in backend/"
        echo ""
        echo "The ASR services require API keys to function properly."
        echo -n "Would you like to set up your API keys now? (y/n): "
        read -r setup_env
        
        if [[ "$setup_env" =~ ^[Yy]$ ]]; then
            create_env_file
        else
            log_error "Cannot continue without API keys"
            echo ""
            echo "Please create backend/.env with:"
            echo "  GEMINI_API_KEY=your_gemini_key"
            echo "  TAVILY_API_KEY=your_tavily_key"
            echo ""
            exit 1
        fi
    else
        # Validate existing .env file
        if ! grep -q "GEMINI_API_KEY=" backend/.env || ! grep -q "TAVILY_API_KEY=" backend/.env; then
            log_warning "Existing .env file is missing required API keys"
            echo ""
            echo "Required keys: GEMINI_API_KEY, TAVILY_API_KEY"
            echo -n "Would you like to recreate the .env file? (y/n): "
            read -r recreate_env
            
            if [[ "$recreate_env" =~ ^[Yy]$ ]]; then
                create_env_file
            else
                log_error "Cannot continue without valid API keys"
                exit 1
            fi
        else
            log_success "Found valid .env file with required API keys"
        fi
    fi
}

# Function to build ASR services in parallel
build_asr_services_parallel() {
    log_info "Building ASR services in parallel..."
    
    local pids=()
    local services=("whisper" "wav2vec" "moonshine" "mesolitica" "vosk" "allosaurus")
    
    for service in "${services[@]}"; do
        (
            build_image "$service-service" "backend/src/asr_models/$service/Dockerfile" "$service-service:latest"
        ) &
        pids+=($!)
    done
    
    # Wait for all background processes
    local failed_builds=()
    for i in "${!pids[@]}"; do
        if ! wait "${pids[$i]}"; then
            failed_builds+=("${services[$i]}")
        fi
    done
    
    if [ ${#failed_builds[@]} -gt 0 ]; then
        log_error "Failed to build services: ${failed_builds[*]}"
        return 1
    else
        log_success "All ASR services built successfully"
        return 0
    fi
}

# Function to build ASR services sequentially
build_asr_services_sequential() {
    log_info "Building ASR services sequentially..."
    
    local services=("whisper" "wav2vec" "moonshine" "mesolitica" "vosk" "allosaurus")
    
    for service in "${services[@]}"; do
        if ! build_image "$service-service" "backend/src/asr_models/$service/Dockerfile" "$service-service:latest"; then
            log_error "Failed to build $service-service, stopping build process"
            return 1
        fi
    done
    
    log_success "All ASR services built successfully"
    return 0
}

# Function to display build summary
show_summary() {
    log_info "Build Summary:"
    echo "=========================="
    
    local images=("asr-base:latest")
    
    if [ "$BUILD_ORCHESTRATOR" = true ]; then
        # Check for docker-compose generated image names
        local project_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]//g')
        images+=("${project_name}-orchestrator:latest" "${project_name}-autocomplete-service:latest")
    fi
    
    images+=("whisper-service:latest" "wav2vec-service:latest" "moonshine-service:latest" 
             "mesolitica-service:latest" "vosk-service:latest" "allosaurus-service:latest"
             "redis:7-alpine")
    
    for image in "${images[@]}"; do
        if docker image inspect "$image" > /dev/null 2>&1; then
            local size=$(docker image inspect "$image" --format='{{.Size}}' | numfmt --to=iec)
            echo -e "${GREEN}✓${NC} $image ($size)"
        else
            # Try without :latest tag for docker-compose images
            local image_no_tag=$(echo "$image" | sed 's/:latest$//')
            if docker image inspect "$image_no_tag" > /dev/null 2>&1; then
                local size=$(docker image inspect "$image_no_tag" --format='{{.Size}}' | numfmt --to=iec)
                echo -e "${GREEN}✓${NC} $image ($size)"
            else
                # For docker-compose services, check if they're running
                local service_name=$(echo "$image" | sed 's/.*-\([^-]*\):.*/\1/')
                if docker compose ps "$service_name" 2>/dev/null | grep -q "Up"; then
                    echo -e "${GREEN}✓${NC} $image (running via docker-compose)"
                else
                    echo -e "${RED}✗${NC} $image (not found)"
                fi
            fi
        fi
    done
    
    echo "=========================="
    local total_size=$(docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}" | grep -E "(asr-base|orchestrator|whisper-service|wav2vec-service|moonshine-service|mesolitica-service|vosk-service|allosaurus-service|autocomplete-service|redis)" | awk '{sum+=$2} END {print sum}' 2>/dev/null || echo "unknown")
    log_info "Total estimated size: $total_size"
}

# Main execution
main() {
    echo "🐳 ASR Docker Build Script"
    echo "=========================="
    
    # Pre-flight checks
    log_info "Performing pre-flight checks..."
    check_docker
    check_prerequisites
    log_success "Pre-flight checks passed"
    
    local start_time=$(date +%s)
    
    # Build base image first (required by all others)
    log_info "Step 1/3: Building base image..."
    if ! build_image "asr-base" "backend/src/asr_models/base.Dockerfile" "asr-base:latest"; then
        log_error "Failed to build base image - cannot continue"
        exit 1
    fi
    
    # Build ASR services
    log_info "Step 2/3: Building ASR services..."
    if [ "$PARALLEL_BUILDS" = true ]; then
        if ! build_asr_services_parallel; then
            log_error "Failed to build ASR services"
            exit 1
        fi
    else
        if ! build_asr_services_sequential; then
            log_error "Failed to build ASR services"
            exit 1
        fi
    fi
    
    # Build orchestrator and supporting services using docker-compose
    if [ "$BUILD_ORCHESTRATOR" = true ]; then
        log_info "Step 3/3: Building orchestrator, autocomplete, and Redis services with docker-compose..."
        if docker compose up --build -d orchestrator autocomplete-service redis; then
            log_success "Orchestrator, autocomplete, and Redis services built and started successfully"
        else
            log_warning "Failed to build orchestrator services with docker-compose"
            log_info "ASR services are still functional without orchestrator"
        fi
    else
        log_info "Step 3/3: Skipping orchestrator service (--no-orchestrator)"
    fi
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    log_success "Build completed in ${duration}s"
    show_summary
    
    # Start services if requested
    if [[ "$START_SERVICES" == true ]]; then
        log_info "Step 4/4: Starting services..."
        echo ""
        
        # Stop existing services first
        log_info "Stopping existing services..."
        docker compose down > /dev/null 2>&1
        
        # Start services
        log_info "Starting services..."
        if docker compose up -d; then
            log_success "Services started successfully"
            echo ""
            log_info "Service status:"
            docker compose ps
            echo ""
            log_info "Useful commands:"
            echo "  • View orchestrator logs: docker compose logs -f orchestrator"
            echo "  • View autocomplete logs: docker compose logs -f autocomplete-service"
            echo "  • Test orchestrator: curl http://localhost:8000/health"
            echo "  • Test autocomplete: curl http://localhost:8007/health"
            echo "  • Test Redis: docker compose exec redis redis-cli ping"
        else
            log_error "Failed to start services"
            exit 1
        fi
    else
        log_info "Next steps:"
        echo "  • Start all services: docker compose up -d"
        echo "  • Start specific ASR service: docker compose up -d whisper-service"
        echo "  • View orchestrator logs: docker compose logs -f orchestrator"
        echo "  • View autocomplete logs: docker compose logs -f autocomplete-service"
        echo "  • Test orchestrator: curl http://localhost:8000/health"
        echo "  • Test autocomplete: curl http://localhost:8007/health"
        echo "  • Test Redis: docker compose exec redis redis-cli ping"
        echo "  • Full autocomplete test: see redis-autocomplete-test-commands.md"
    fi
}

# Run main function
main "$@"